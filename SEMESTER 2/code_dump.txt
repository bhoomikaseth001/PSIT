
                                   LECTURE17                                    
                              BinarySearchTree.cpp               

/*BINARY SEARCH TREE*/
#include <iostream>
using namespace std;

typedef struct node {
    int value;
    struct node *left;
    struct node *right;
}NODE;

NODE* newNode(int val) {
    struct node *temp = new struct node;
    temp->value = val;
    temp->left = NULL;
    temp->right = NULL;
    return temp;
}

void insert(NODE *&root, int item) {
    NODE*ptr = root;
    NODE*ptr1 = NULL; 
    bool flag = false;

    while (ptr != NULL && !flag) {
        if (item < ptr->value) { 
            ptr1 = ptr;
            ptr = ptr->left;
        } else if (item > ptr->value) { 
            ptr1 = ptr;
            ptr = ptr->right;
        } else {
            flag = true;
            cout << "Item already exists." << endl;
            return;
        }
    }
    if (ptr == NULL) {
       NODE*newNode = new NODE;
        newNode->value = item; 
        newNode->left = NULL;
        newNode->right = NULL;

        if (ptr1 == NULL) {
            root = newNode;
        } else if (ptr1->value < item) {
            ptr1->right = newNode;
        } else {
            ptr1->left = newNode;
        }
    }
}

void inorderTraversal(NODE *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        cout << root->value << " ";
        inorderTraversal(root->right);
    }
}

void preorderTraversal(NODE *root) {
    if (root != NULL) {
        cout << root->value << " ";
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

void postorderTraversal(NODE *root) {
    if (root != NULL) {
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        cout << root->value << " ";
    }
}

int main() {
    NODE *root = NULL; 
    insert(root, 5);
    insert(root, 3);
    insert(root, 7);
    insert(root, 2);
    insert(root, 4);
    insert(root, 6);
    insert(root, 8);
    insert(root, 5); 
    cout << "In-order traversal of the BST: ";
    inorderTraversal(root);
    cout << endl;

    cout << "Pre-order traversal of the BST: ";
    preorderTraversal(root);
    cout << endl;

    cout << "Post-order traversal of the BST: ";
    postorderTraversal(root);
    cout << endl;
    }
    /*Output:
                Item already exists.
                In-order traversal of the BST: 2 3 4 5 6 7 8
                Pre-order traversal of the BST: 5 3 2 4 7 6 8
                Post-order traversal of the BST: 2 4 3 6 8 7 5 */


                                   LECTURE18                                    
                                  capacity.cpp                                  

// Demonstrate that the Vectors are dynamic in nature

#include <iostream>
#include <vector>
int main() {
    using namespace std;
vector<int> vec;
// Display initial size and capacity
cout << "Initial size: " << vec.size() << ", capacity: " << vec.capacity() <<endl;
// Add elements to the vector and observe capacity changes
for (int i = 0; i < 20; ++i) {
vec.push_back(i);
cout<<"After adding element "<<i<<" ,  size: "<<vec.size()<<", capacity: "<<vec.capacity()<<endl;
}
// Remove elements from the vector
for (int i = 0; i < 10; ++i) {
vec.pop_back();
cout<<"After removing element, size: " <<vec.size()<< ", capacity: "<<vec.capacity()<<endl;
}
// Clear the vector
vec.clear();
cout<<"After clearing, size: "<<vec.size()<<", capacity: "<<vec.capacity()<<endl;
return 0;
}
/*Output: 
            Initial size: 0, capacity: 0
            After adding element 0 , size: 1, capacity: 1
            After adding element 1 , size: 2, capacity: 2
            After adding element 2 ,  size: 3, capacity: 4
            After adding element 3 ,  size: 4, capacity: 4
            After adding element 4 ,  size: 5, capacity: 8...
            After adding element 7 ,  size: 8, capacity: 8
            After adding element 8 ,  size: 9, capacity: 16
            After adding element 9 ,  size: 10, capacity: 16...
            After adding element 14 ,  size: 15, capacity: 16
            After adding element 15 ,  size: 16, capacity: 16
            After adding element 16 ,  size: 17, capacity: 32
            
            After removing element, size: 16, capacity: 32
            After removing element, size: 15, capacity: 32
            After removing element, size: 14, capacity: 32
            After removing element, size: 13, capacity: 32....
            After clearing, size: 0, capacity: 32   */


                                    LECTURE18                                    
                                ChainHashing.cpp                                

// Program to show chain hashing in c++ for collision removal

#include <iostream>
#include <vector>
using namespace std;
// Node structure for the linked list in each bucket
struct Node {
    int key;
    Node* next;
    Node(int k) : key(k), next(nullptr) {}
};

// Hash table using chain hashing
class HashTable {
    private:
    vector<Node*> table;
    int tableSize;
    public:
    // Constructor
    HashTable(int size) : tableSize(size) {
        table.resize(tableSize, nullptr);
    }
    // Hash function (k mod 10)
    int hashFunction(int key) {
        return key % tableSize;
    }
    // Insert a key into the hash table
    void insert(int key) {
        int index = hashFunction(key);
        Node* newNode = new Node(key);
        newNode->next = table[index];

        table[index] = newNode;
    }
    // Print the hash table
    void printHashTable() {
        for (int i = 0; i < tableSize; ++i) {
            cout << "Bucket " << i << ": ";
            Node* current = table[i];
            while (current) {
                cout << current->key << " -> ";
                current = current->next;
            }       
        cout << "NULL" << endl;
        }
        }
};
int main() {
    HashTable ht(10); // Create hash table with bucket size 10
    // Insert keys into the hash table
    ht.insert(1);
    ht.insert(11);
    ht.insert(21);
    ht.insert(3);
    ht.insert(13);
    ht.insert(23);
    ht.insert(24);
    ht.insert(25);
    ht.insert(26);
    // Print the hash table
    ht.printHashTable();
     } 

    /*Output: 
                Bucket 0: NULL
                Bucket 1: 21 -> 11 -> 1 -> NULL
                Bucket 2: NULL
                Bucket 3: 23 -> 13 -> 3 -> NULL
                Bucket 4: 24 -> NULL
                Bucket 5: 25 -> NULL
                Bucket 6: 26 -> NULL
                Bucket 7: NULL
                Bucket 8: NULL
                Bucket 9: NULL */


                                   LECTURE18                                    
                                UnorderedMap.cpp     

// Functions of the unordered map
#include <iostream>
#include <unordered_map>
#include <string> 
using namespace std;
int main() {
unordered_map<int,string> malay;
malay [1] = "one";
malay [2] = "two";
malay [3] = "three";

cout << "Key 1 has value: "<< malay [1] << endl;
cout << "Key 2 has value: " <<malay [2] << endl;
// Check if a key exists
int key = 4;
auto it = malay.find(key);
if (it != malay.end()) {
cout << "Found key " << key << " with value: " << it->second << endl;
} else {
cout << "Key " << key << " not found" << endl;
}
// Erase an element
malay.erase(2);
cout << "After erasing key 2, size of map: " << malay.size() << endl;
// Check if map is empty
if (malay.empty()) {
cout << "Map is empty" << endl;
} else {
cout << "Map is not empty" << endl;
}
// Clear the map
malay.clear();
cout << "After clearing, size of map: " << malay.size() << endl;
return 0;
}

/*Output :
            Key 1 has value: one
            Key 2 has value: two
            Key 4 not found
            After erasing key 2, size of map: 2
            Map is not empty
            After clearing, size of map: 0   */

